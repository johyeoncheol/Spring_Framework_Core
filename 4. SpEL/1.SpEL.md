# SpEL (Spring Expression Language)

## 스프링 EL이란?
- 객체 그래프를 조회하고 조작하는 기능을 제공한다.
- Unified EL과 비슷하지만, 메소드 호출을 지원하며, 문자열 템플릿 기능도 제공한다.
- OGNL, MVEL, JBOss EL 등 자바에서 사용할 수 있는 여러 EL이 있지만, SpEL은 모든 스프링 프로젝트 전반에 걸쳐 사용할 EL로 만들었다.
- 스프링 3.0부터 지원

```
객체 Graph 란?
객체지향 프로그래밍에서 각각의 객체들은 주어진 역활과 책임을 감당하기 위해 다른 객체들을 참조하며 유기적인 관계를 맺고 있습니다. 이렇게 참조틑 통한 관계로 묶인 객체들의 group을 객체 graph라고 합니다.
```

## SpEL 지원 기능
- 리터럴 표현식 (Literal Expression)
- Boolean과 관계연산자 (Boolean and Relational Operator)
- 정규 표현식 (Regular Expression)
- 클래스 표현식 (Class Expression)
- 프로퍼티, 배열, 리스트, 맵에 대한 접근 지원 (Accessing properties, arrays, lists, maps)
- 메서드 호출 (Method Invocation)
- 관계연산자 (Relational Operator)
- 할당 (Assignment)
- 생성자 호출 (Calling Constructors)
- Bean 참조 (Bean References)
- 배열 생성 (Array Contruction)
- 인라인 리스트/맵 (Inline List/Map)
- 삼항 연산자 (Ternary Operator)
- 변수 (Variables)
- 사용자 정의 함수 (User defined functions)
- 컬렉션 투영 (Collections Projection)
- 컬렉션 선택 (Collections Selection)
- 템플릿화된 표현식 (Templated expression)

## SpEL 구성
- ExpressionParser parser = new SpelExpressionParser()
- StandardEvaluationContext context = new StandardEvaluationContext(bean)
- Expression expression = parser.parseExpression("SpEL 표현식")
- String Value = expression.getValue(context, String.class)

## 문법
- #("표현식")
- $("프로퍼티")
- 표현식은 프로피트를 가질 수 있지만, 반대는 안 됨
  + #{${my.data}+1}
- 레퍼런스 참고

## 실제로 어디서 쓰나?
- @Value 애노테이션
- @ConditionalOnExpression 애노테이션
- 스프링 시큐리티
  + 메소드 시큐리티
  + XML 인터셉터 URL 설정
- 스프링 데이터
  + @Query 애노테이션
- Thymeleaf

### @Value 어노테이션에서 SpEl 사용
```
@Value("#{1+1}")
int value;
 
@Value("#{'hello ' + 'world'}")
String greeting;
 
@Value("#{1 eq 5}")
boolean trueOrFalse;
 
@Value("Literal String")
String literalString;
 
@Override
public void run(ApplicationArguments args) throws Exception {
    System.out.println(value);
    System.out.println(greeting);
    System.out.println(trueOrFalse);
    System.out.println(literalString);
}
```

### SpEL과 프로퍼티
```
@Value("#{'${my.value}' eq '100'}")
boolean isEqual;
 
@Override
public void run(ApplicationArguments args) throws Exception {
    System.out.println(isEqual);
}
```

### Bean Reference 방법
```
import org.springframework.stereotype.Component;
 
@Component
public class Sample {
    
    private int value = 123;
 
    public int getValue() {
        return value;
    }
}
```

```
@Value("#{sample.Value}")
int sampleValue;
 
@Override
public void run(ApplicationArguments args) throws Exception {
    System.out.println(sampleValue);
}
```

### Expression을 이용한 SpEL 파싱
```
ExpressionParser parser = new SpelExpressionParser();
Expression expression = parser.parseExpression("1+1");
Object value = expression.getValue();
System.out.println(value);
```

```
ExpressionParser parser = new SpelExpressionParser();
Expression expression = parser.parseExpression("1+1");
int value = expression.getValue(Integer.class);
System.out.println(value);
```

### EvaluationContext를 이용한 SpEL 파싱
```
// name, nationality를 파라미터로 갖는 생성자
Inventor tesla = new Inventor("Nikola Tesla","Serbian");
 
ExpressionParser parser = new SpelExpressionParser();
Expression exp = parser.parseExpression("name"); // name 프로퍼티
 
// Context에 tesla객체를 넣어준다.
EvaluationContext context = new StandardEvaluationContext(tesla);
String name1 = (String) exp.getValue(context); //name = "Nikola Tesla"
System.out.println(name1);  // Nikola Tesla
 
// getValue 메서드 호출 시 StandardEvaluationContext를 사용하지 않고 객체를 직접 지정
String name2 = (String) exp.getValue(tesla);
System.out.println(name2);  // Nikola Tesla
```